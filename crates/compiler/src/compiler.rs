use monke_core::{
    ast::{BlockStatement, Expression, Program, Statement},
    object::{Integer, Object},
    token::TokenType,
};

use crate::{
    code::{Instructions, Opcode, make},
    symbol_table::SymbolTable,
};

#[derive(Copy, Clone)]
pub struct EmittedInstruction {
    opcode: Opcode,
    position: i64,
}

pub struct Compiler {
    /// holds generated bytecode
    instructions: Instructions,

    /// constant pool
    constants: Vec<Object>,

    last_instruction: Option<EmittedInstruction>,
    prev_instruction: Option<EmittedInstruction>,

    symbol_table: SymbolTable,
}

#[derive(Clone)]
pub struct Bytecode {
    pub instructions: Instructions,
    pub constants: Vec<Object>,
}

#[derive(Debug)]
pub enum CompilerError {
    // todo: remove later
    Unknown,

    UndefinedVariable,
}

impl Compiler {
    pub fn new() -> Self {
        Self {
            instructions: Instructions::new(),
            constants: vec![],
            last_instruction: None,
            prev_instruction: None,
            symbol_table: SymbolTable::new(),
        }
    }

    pub fn new_with_state(symbol_table: SymbolTable, constants: Vec<Object>) -> Self {
        let mut compiler = Compiler::new();
        compiler.symbol_table = symbol_table;
        compiler.constants = constants;

        compiler
    }

    pub fn compile(&mut self, program: Program) -> Result<(), CompilerError> {
        for stmt in program.body {
            let result = self.compile_statement(&stmt);

            if result.is_err() {
                return result;
            }
        }

        Ok(())
    }

    fn compile_statement(&mut self, statement: &Statement) -> Result<(), CompilerError> {
        match statement {
            Statement::ExpressionStatement(expression_statement) => {
                if let Some(expression) = &expression_statement.expression {
                    self.compile_expression(&expression)?;
                    self.emit(Opcode::OpPop, &[]);
                    return Ok(());
                }

                Err(CompilerError::Unknown)
            }
            Statement::LetStatement(let_statement) => {
                let Some(let_val) = &let_statement.value else {
                    return Err(CompilerError::Unknown);
                };

                self.compile_expression(&let_val)?;
                let symbol = self.symbol_table.define(&let_statement.name.value);
                self.emit(Opcode::OpSetGlobal, &[symbol.index]);

                Ok(())
            }
            Statement::ReturnStatement(return_statement) => todo!(),
            Statement::BlockStatement(block_statement) => {
                self.compile_block_statement(block_statement)
            }
            Statement::ForStatement(for_statement) => todo!(),
        }
    }

    pub fn bytecode(&self) -> Bytecode {
        Bytecode {
            instructions: self.instructions.clone(),
            constants: self.constants.clone(),
        }
    }

    fn compile_block_statement(
        &mut self,
        block_statement: &BlockStatement,
    ) -> Result<(), CompilerError> {
        for stmt in &block_statement.statements {
            self.compile_statement(&stmt)?;
        }

        Ok(())
    }

    fn compile_expression(&mut self, expression: &Expression) -> Result<(), CompilerError> {
        match expression {
            Expression::IntegerLiteral(integer_literal) => {
                let integer = Object::Integer(Box::new(Integer {
                    value: integer_literal.value,
                }));

                let index = self.add_constant(integer);
                self.emit(Opcode::OpConstant, &[index]);

                Ok(())
            }
            Expression::InfixExpression(infix) => {
                if infix.operator == TokenType::Lt {
                    let right_result = self.compile_expression(&infix.right)?;
                    let left_result = self.compile_expression(&infix.left)?;

                    self.emit(Opcode::OpGreaterThan, &[]);
                    return Ok(());
                }

                let left_result = self.compile_expression(&infix.left)?;
                let right_result = self.compile_expression(&infix.right)?;

                match infix.operator {
                    TokenType::Plus => self.emit(Opcode::OpAdd, &[]),
                    TokenType::Minus => self.emit(Opcode::OpSub, &[]),
                    TokenType::Asterisk => self.emit(Opcode::OpMul, &[]),
                    TokenType::Slash => self.emit(Opcode::OpDiv, &[]),
                    TokenType::Gt => self.emit(Opcode::OpGreaterThan, &[]),
                    TokenType::Eq => self.emit(Opcode::OpEqual, &[]),
                    TokenType::NotEq => self.emit(Opcode::OpNotEqual, &[]),
                    _ => unreachable!("unknown operator"),
                };

                Ok(())
            }
            Expression::PrefixExpression(prefix_expr) => {
                let right_result = self.compile_expression(&prefix_expr.right)?;

                match prefix_expr.operator {
                    TokenType::Bang => self.emit(Opcode::OpBang, &[]),
                    TokenType::Minus => self.emit(Opcode::OpMinus, &[]),
                    _ => unreachable!("unknown operator"),
                };

                Ok(())
            }
            Expression::Boolean(bool_expr) => {
                match bool_expr.value {
                    true => self.emit(Opcode::OpTrue, &[]),
                    false => self.emit(Opcode::OpFalse, &[]),
                };
                Ok(())
            }
            Expression::IfExpression(if_expr) => {
                self.compile_expression(&if_expr.condition)?;

                let jump_not_truthy_pos = self.emit(Opcode::OpJumpNotTruthy, &[9999]);

                self.compile_block_statement(&if_expr.consequence)?;

                if self.is_last_ins_pop() {
                    self.remove_last_pop();
                }

                let jump_pos = self.emit(Opcode::OpJump, &[9999]);

                let after_conseq_position = self.instructions.len();
                self.change_operand(
                    jump_not_truthy_pos,
                    after_conseq_position.try_into().unwrap(),
                );

                if let Some(alt) = &if_expr.alternative {
                    self.compile_block_statement(&alt)?;

                    if self.is_last_ins_pop() {
                        self.remove_last_pop();
                    }
                } else {
                    self.emit(Opcode::OpNull, &[]);
                }

                let after_alt_position = self.instructions.len();
                self.change_operand(jump_pos, after_alt_position.try_into().unwrap());

                Ok(())
            }
            Expression::Identifier(ident) => {
                let symbol = self.symbol_table.resolve(&ident.value);

                let Some(symbol) = symbol else {
                    return Err(CompilerError::UndefinedVariable);
                };

                self.emit(Opcode::OpGetGlobal, &[symbol.index]);

                Ok(())
            }
            value => todo!("{:?} not implemented", value),
        }
    }

    /// adds object to pool of constants
    fn add_constant(&mut self, obj: Object) -> i64 {
        self.constants.push(obj);
        (self.constants.len() - 1).try_into().unwrap()
    }

    fn emit(&mut self, opcode: Opcode, operands: &[i64]) -> i64 {
        let instruction = make(opcode, &operands);
        let position = self.add_instruction(&instruction);
        self.set_last_instruction(opcode, position);

        position
    }

    fn add_instruction(&mut self, instruction: &Vec<u8>) -> i64 {
        let pos_new_instruction = self.instructions.len();
        self.instructions.extend(instruction);
        pos_new_instruction.try_into().unwrap()
    }

    fn set_last_instruction(&mut self, opcode: Opcode, position: i64) {
        let prev = self.last_instruction;
        let last = EmittedInstruction { opcode, position };
        self.prev_instruction = prev;
        self.last_instruction = Some(last);
    }

    fn is_last_ins_pop(&self) -> bool {
        self.last_instruction
            .is_some_and(|ins| ins.opcode == Opcode::OpPop)
    }

    fn remove_last_pop(&mut self) {
        self.instructions.pop();
        self.last_instruction = self.prev_instruction;
    }

    fn replace_instruction(&mut self, position: i64, new_instruction: Vec<u8>) {
        for i in 0..new_instruction.len() {
            self.instructions[position as usize + i] = new_instruction[i];
        }
    }

    fn change_operand(&mut self, op_position: i64, operand: i64) {
        let opcode = Opcode::from_byte(self.instructions[op_position as usize]);

        let Some(opcode) = opcode else {
            return;
        };

        let new_instruction = make(opcode, &[operand]);
        self.replace_instruction(op_position, new_instruction);
    }
}

#[cfg(test)]
mod tests {
    use monke_core::{ast, lexer::Lexer, object::Object, parser::Parser};

    use crate::{
        code::{self, Instructions, Opcode, make, read_operands},
        compiler::Compiler,
    };

    enum ExpectedConstant {
        I64(i64),
        Bool(bool),
    }

    struct CompilerTestCase {
        input: String,
        expected_constants: Vec<ExpectedConstant>,
        expected_instructions: Vec<Instructions>,
    }

    #[test]
    fn test_integer_arithmetic() {
        let tests = vec![
            CompilerTestCase {
                input: "1; 2".to_string(),
                expected_constants: vec![ExpectedConstant::I64(1), ExpectedConstant::I64(2)],
                expected_instructions: vec![
                    Instructions(code::make(Opcode::OpConstant, &[0])),
                    Instructions(code::make(Opcode::OpPop, &[])),
                    Instructions(code::make(Opcode::OpConstant, &[1])),
                    Instructions(code::make(Opcode::OpPop, &[])),
                ],
            },
            CompilerTestCase {
                input: "1 + 2".to_string(),
                expected_constants: vec![ExpectedConstant::I64(1), ExpectedConstant::I64(2)],
                expected_instructions: vec![
                    Instructions(code::make(Opcode::OpConstant, &[0])),
                    Instructions(code::make(Opcode::OpConstant, &[1])),
                    Instructions(code::make(Opcode::OpAdd, &[])),
                    Instructions(code::make(Opcode::OpPop, &[])),
                ],
            },
            CompilerTestCase {
                input: "1 - 2".to_string(),
                expected_constants: vec![ExpectedConstant::I64(1), ExpectedConstant::I64(2)],
                expected_instructions: vec![
                    Instructions(code::make(Opcode::OpConstant, &[0])),
                    Instructions(code::make(Opcode::OpConstant, &[1])),
                    Instructions(code::make(Opcode::OpSub, &[])),
                    Instructions(code::make(Opcode::OpPop, &[])),
                ],
            },
            CompilerTestCase {
                input: "1 * 2".to_string(),
                expected_constants: vec![ExpectedConstant::I64(1), ExpectedConstant::I64(2)],
                expected_instructions: vec![
                    Instructions(code::make(Opcode::OpConstant, &[0])),
                    Instructions(code::make(Opcode::OpConstant, &[1])),
                    Instructions(code::make(Opcode::OpMul, &[])),
                    Instructions(code::make(Opcode::OpPop, &[])),
                ],
            },
            CompilerTestCase {
                input: "2 / 1".to_string(),
                expected_constants: vec![ExpectedConstant::I64(2), ExpectedConstant::I64(1)],
                expected_instructions: vec![
                    Instructions(code::make(Opcode::OpConstant, &[0])),
                    Instructions(code::make(Opcode::OpConstant, &[1])),
                    Instructions(code::make(Opcode::OpDiv, &[])),
                    Instructions(code::make(Opcode::OpPop, &[])),
                ],
            },
            CompilerTestCase {
                input: "-1".to_string(),
                expected_constants: vec![ExpectedConstant::I64(1)],
                expected_instructions: vec![
                    Instructions(code::make(Opcode::OpConstant, &[0])),
                    Instructions(code::make(Opcode::OpMinus, &[])),
                    Instructions(code::make(Opcode::OpPop, &[])),
                ],
            },
        ];

        run_compiler_tests(tests);
    }

    #[test]
    fn test_instructions_string() {
        let instructions = vec![
            make(Opcode::OpConstant, &[1]),
            make(Opcode::OpConstant, &[2]),
            make(Opcode::OpConstant, &[65535]),
        ];

        let expected = "0000 OpConstant 1 \n0003 OpConstant 2 \n0006 OpConstant 65535 \n";

        let concated: Instructions = instructions.into_iter().flat_map(|i| i).collect();

        assert_eq!(expected, concated.to_string());
    }

    #[test]
    fn test_read_operands() {
        struct TestCase {
            op: Opcode,
            operands: Vec<i64>,
            bytes_read: i64,
        }

        let tests: Vec<TestCase> = vec![TestCase {
            op: Opcode::OpConstant,
            operands: vec![65535],
            bytes_read: 2,
        }];

        for test in tests {
            let instruction = make(test.op, &test.operands);

            let def = test.op.get_definition();

            let (operands_read, n) = read_operands(&def, &instruction[1..]);

            assert_eq!(
                n, test.bytes_read,
                "n wrong. want: {}, got: {}",
                test.bytes_read, n
            );

            for (i, want) in test.operands.iter().enumerate() {
                assert_eq!(
                    operands_read[i], *want,
                    "operand wrong. want: {}, got: {}",
                    want, operands_read[i]
                )
            }
        }
    }

    #[test]
    fn test_boolean_expression() {
        let tests = vec![
            CompilerTestCase {
                input: "true".to_string(),
                expected_constants: vec![],
                expected_instructions: vec![
                    Instructions(code::make(Opcode::OpTrue, &[])),
                    Instructions(code::make(Opcode::OpPop, &[])),
                ],
            },
            CompilerTestCase {
                input: "false".to_string(),
                expected_constants: vec![],
                expected_instructions: vec![
                    Instructions(code::make(Opcode::OpFalse, &[])),
                    Instructions(code::make(Opcode::OpPop, &[])),
                ],
            },
            CompilerTestCase {
                input: "1 > 2".to_string(),
                expected_constants: vec![ExpectedConstant::I64(1), ExpectedConstant::I64(2)],
                expected_instructions: vec![
                    Instructions(code::make(Opcode::OpConstant, &[0])),
                    Instructions(code::make(Opcode::OpConstant, &[1])),
                    Instructions(code::make(Opcode::OpGreaterThan, &[])),
                    Instructions(code::make(Opcode::OpPop, &[])),
                ],
            },
            CompilerTestCase {
                input: "1 < 2".to_string(),
                expected_constants: vec![ExpectedConstant::I64(2), ExpectedConstant::I64(1)],
                expected_instructions: vec![
                    Instructions(code::make(Opcode::OpConstant, &[0])),
                    Instructions(code::make(Opcode::OpConstant, &[1])),
                    Instructions(code::make(Opcode::OpGreaterThan, &[])),
                    Instructions(code::make(Opcode::OpPop, &[])),
                ],
            },
            CompilerTestCase {
                input: "1 == 2".to_string(),
                expected_constants: vec![ExpectedConstant::I64(1), ExpectedConstant::I64(2)],
                expected_instructions: vec![
                    Instructions(code::make(Opcode::OpConstant, &[0])),
                    Instructions(code::make(Opcode::OpConstant, &[1])),
                    Instructions(code::make(Opcode::OpEqual, &[])),
                    Instructions(code::make(Opcode::OpPop, &[])),
                ],
            },
            CompilerTestCase {
                input: "1 != 2".to_string(),
                expected_constants: vec![ExpectedConstant::I64(1), ExpectedConstant::I64(2)],
                expected_instructions: vec![
                    Instructions(code::make(Opcode::OpConstant, &[0])),
                    Instructions(code::make(Opcode::OpConstant, &[1])),
                    Instructions(code::make(Opcode::OpNotEqual, &[])),
                    Instructions(code::make(Opcode::OpPop, &[])),
                ],
            },
            CompilerTestCase {
                input: "true == false".to_string(),
                expected_constants: vec![],
                expected_instructions: vec![
                    Instructions(code::make(Opcode::OpTrue, &[])),
                    Instructions(code::make(Opcode::OpFalse, &[])),
                    Instructions(code::make(Opcode::OpEqual, &[])),
                    Instructions(code::make(Opcode::OpPop, &[])),
                ],
            },
            CompilerTestCase {
                input: "true != false".to_string(),
                expected_constants: vec![],
                expected_instructions: vec![
                    Instructions(code::make(Opcode::OpTrue, &[])),
                    Instructions(code::make(Opcode::OpFalse, &[])),
                    Instructions(code::make(Opcode::OpNotEqual, &[])),
                    Instructions(code::make(Opcode::OpPop, &[])),
                ],
            },
            CompilerTestCase {
                input: "!true".to_string(),
                expected_constants: vec![],
                expected_instructions: vec![
                    Instructions(code::make(Opcode::OpTrue, &[])),
                    Instructions(code::make(Opcode::OpBang, &[])),
                    Instructions(code::make(Opcode::OpPop, &[])),
                ],
            },
        ];

        run_compiler_tests(tests);
    }

    #[test]
    fn test_conditionals() {
        let tests = vec![
            CompilerTestCase {
                input: "if (true) { 10 } else { 20 }; 3333;".to_string(),
                expected_constants: vec![
                    ExpectedConstant::I64(10),
                    ExpectedConstant::I64(20),
                    ExpectedConstant::I64(3333),
                ],
                expected_instructions: vec![
                    Instructions(make(Opcode::OpTrue, &[])),
                    Instructions(make(Opcode::OpJumpNotTruthy, &[10])),
                    Instructions(make(Opcode::OpConstant, &[0])),
                    Instructions(make(Opcode::OpJump, &[13])),
                    Instructions(make(Opcode::OpConstant, &[1])),
                    Instructions(make(Opcode::OpPop, &[])),
                    Instructions(make(Opcode::OpConstant, &[2])),
                    Instructions(make(Opcode::OpPop, &[])),
                ],
            },
            CompilerTestCase {
                input: "if (true) { 10 }; 3333;".to_string(),
                expected_constants: vec![ExpectedConstant::I64(10), ExpectedConstant::I64(3333)],
                expected_instructions: vec![
                    Instructions(make(Opcode::OpTrue, &[])),
                    Instructions(make(Opcode::OpJumpNotTruthy, &[10])),
                    Instructions(make(Opcode::OpConstant, &[0])),
                    Instructions(make(Opcode::OpJump, &[11])),
                    Instructions(make(Opcode::OpNull, &[])),
                    Instructions(make(Opcode::OpPop, &[])),
                    Instructions(make(Opcode::OpConstant, &[1])),
                    Instructions(make(Opcode::OpPop, &[])),
                ],
            },
        ];

        run_compiler_tests(tests);
    }

    #[test]
    fn test_global_let_statements() {
        let tests = vec![
            CompilerTestCase {
                input: "
                let one = 1;
                let two = 2;
                "
                .to_string(),
                expected_constants: vec![ExpectedConstant::I64(1), ExpectedConstant::I64(2)],
                expected_instructions: vec![
                    Instructions(make(Opcode::OpConstant, &[0])),
                    Instructions(make(Opcode::OpSetGlobal, &[0])),
                    Instructions(make(Opcode::OpConstant, &[1])),
                    Instructions(make(Opcode::OpSetGlobal, &[1])),
                ],
            },
            CompilerTestCase {
                input: "
                let one = 1;
                one;
                "
                .to_string(),
                expected_constants: vec![ExpectedConstant::I64(1)],
                expected_instructions: vec![
                    Instructions(make(Opcode::OpConstant, &[0])),
                    Instructions(make(Opcode::OpSetGlobal, &[0])),
                    Instructions(make(Opcode::OpGetGlobal, &[0])),
                    Instructions(make(Opcode::OpPop, &[])),
                ],
            },
            CompilerTestCase {
                input: "
                let one = 1;
                let two = one;
                two;
                "
                .to_string(),
                expected_constants: vec![ExpectedConstant::I64(1)],
                expected_instructions: vec![
                    Instructions(make(Opcode::OpConstant, &[0])),
                    Instructions(make(Opcode::OpSetGlobal, &[0])),
                    Instructions(make(Opcode::OpGetGlobal, &[0])),
                    Instructions(make(Opcode::OpSetGlobal, &[1])),
                    Instructions(make(Opcode::OpGetGlobal, &[1])),
                    Instructions(make(Opcode::OpPop, &[])),
                ],
            },
        ];

        run_compiler_tests(tests);
    }

    fn run_compiler_tests(tests: Vec<CompilerTestCase>) {
        for test in tests {
            let program = parse(test.input);
            let mut compiler = Compiler::new();

            assert!(
                compiler.compile(program).is_ok(),
                "failed to compile program"
            );

            let bytecode = compiler.bytecode();

            test_instructions(test.expected_instructions, bytecode.instructions);
            test_constants(test.expected_constants, bytecode.constants);
        }
    }

    fn test_constants(expected: Vec<ExpectedConstant>, actual: Vec<Object>) {
        assert_eq!(
            actual.len(),
            expected.len(),
            "wrong constants length, want: {}, got: {}",
            expected.len(),
            actual.len()
        );

        for (idx, constant) in expected.iter().enumerate() {
            match constant {
                ExpectedConstant::I64(constant) => test_integer_object(constant, &actual[idx]),
                ExpectedConstant::Bool(boolean) => test_boolean_object(boolean, &actual[idx]),
            }
        }
    }

    fn test_boolean_object(expected: &bool, actual: &Object) {
        let Object::Boolean(bool_obj) = actual else {
            panic!("object is not Integer. got: {}", actual);
        };

        assert_eq!(
            bool_obj.value, *expected,
            "object has wrong value. got: {}, want: {}",
            bool_obj.value, expected
        );
    }

    fn test_integer_object(expected: &i64, actual: &Object) {
        let Object::Integer(int_obj) = actual else {
            panic!("object is not Integer. got: {}", actual);
        };

        assert_eq!(
            int_obj.value, *expected,
            "object has wrong value. got: {}, want: {}",
            int_obj.value, expected
        );
    }

    fn test_instructions(expected: Vec<Instructions>, actual: Instructions) {
        let concated: Instructions = expected.into_iter().flat_map(|i| i).collect();

        assert_eq!(
            actual.len(),
            concated.len(),
            "wrong instructions length, want: {}, got: {}",
            concated,
            actual
        );

        for (idx, ins) in concated.iter().enumerate() {
            assert_eq!(
                actual[idx], *ins,
                "wrong instruction at {}, want: {}, got: {}",
                idx, ins, actual[idx]
            )
        }
    }

    fn parse(input: String) -> ast::Program {
        let lexer = Lexer::new(input);
        let mut parser = Parser::new(lexer);
        return parser.parse_program();
    }
}
