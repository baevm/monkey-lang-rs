use monke_core::{
    ast::{BlockStatement, Expression, Program, Statement},
    object::{CompiledFunction, Integer, Object, StringObj},
    token::TokenType,
};

use crate::{
    code::{Instructions, Opcode, make},
    symbol_table::SymbolTable,
};

#[derive(Copy, Clone)]
pub struct EmittedInstruction {
    opcode: Opcode,
    position: i64,
}

struct CompilationScope {
    instructions: Instructions,
    last_instruction: Option<EmittedInstruction>,
    prev_instruction: Option<EmittedInstruction>,
}

pub struct Compiler {
    /// constant pool
    constants: Vec<Object>,

    symbol_table: SymbolTable,

    /// holds generated bytecode
    scopes: Vec<CompilationScope>,
    scope_index: usize,
}

#[derive(Clone)]
pub struct Bytecode {
    pub instructions: Instructions,
    pub constants: Vec<Object>,
}

#[derive(Debug)]
pub enum CompilerError {
    // todo: remove later
    Unknown,

    UndefinedVariable,
}

impl Compiler {
    pub fn new() -> Self {
        let main_scope = CompilationScope {
            instructions: Instructions::new(),
            last_instruction: None,
            prev_instruction: None,
        };

        Self {
            constants: vec![],
            symbol_table: SymbolTable::new(),
            scopes: vec![main_scope],
            scope_index: 0,
        }
    }

    pub fn new_with_state(symbol_table: SymbolTable, constants: Vec<Object>) -> Self {
        let mut compiler = Compiler::new();
        compiler.symbol_table = symbol_table;
        compiler.constants = constants;

        compiler
    }

    pub fn compile(&mut self, program: Program) -> Result<(), CompilerError> {
        for stmt in program.body {
            let result = self.compile_statement(&stmt);

            if result.is_err() {
                return result;
            }
        }

        Ok(())
    }

    fn current_instructions(&self) -> &Instructions {
        &self.scopes[self.scope_index].instructions
    }

    fn enter_scope(&mut self) {
        let scope = CompilationScope {
            instructions: Instructions::new(),
            last_instruction: None,
            prev_instruction: None,
        };

        self.scopes.push(scope);
        self.scope_index += 1;
    }

    fn leave_scope(&mut self) -> Instructions {
        let instructions = self.current_instructions().clone();

        self.scopes.pop();
        self.scope_index -= 1;

        instructions
    }

    fn compile_statement(&mut self, statement: &Statement) -> Result<(), CompilerError> {
        match statement {
            Statement::ExpressionStatement(expression_statement) => {
                if let Some(expression) = &expression_statement.expression {
                    self.compile_expression(&expression)?;
                    self.emit(Opcode::OpPop, &[]);
                    return Ok(());
                }

                Err(CompilerError::Unknown)
            }
            Statement::LetStatement(let_statement) => {
                let Some(let_val) = &let_statement.value else {
                    return Err(CompilerError::Unknown);
                };

                self.compile_expression(&let_val)?;
                let symbol = self.symbol_table.define(&let_statement.name.value);
                self.emit(Opcode::OpSetGlobal, &[symbol.index]);

                Ok(())
            }
            Statement::ReturnStatement(return_stmt) => {
                if let Some(ret_val) = &return_stmt.return_value {
                    self.compile_expression(ret_val)?;
                    self.emit(Opcode::OpReturnValue, &[]);
                } else {
                    self.emit(Opcode::OpReturn, &[]);
                }

                Ok(())
            }
            Statement::BlockStatement(block_statement) => {
                self.compile_block_statement(block_statement)
            }
            Statement::ForStatement(_) => todo!(),
        }
    }

    pub fn bytecode(&self) -> Bytecode {
        Bytecode {
            instructions: self.current_instructions().clone(),
            constants: self.constants.clone(),
        }
    }

    fn compile_block_statement(
        &mut self,
        block_statement: &BlockStatement,
    ) -> Result<(), CompilerError> {
        for stmt in &block_statement.statements {
            self.compile_statement(&stmt)?;
        }

        Ok(())
    }

    fn compile_expression(&mut self, expression: &Expression) -> Result<(), CompilerError> {
        match expression {
            Expression::IntegerLiteral(integer_literal) => {
                let integer = Object::Integer(Box::new(Integer {
                    value: integer_literal.value,
                }));

                let index = self.add_constant(integer);
                self.emit(Opcode::OpConstant, &[index]);

                Ok(())
            }
            Expression::InfixExpression(infix) => {
                if infix.operator == TokenType::Lt {
                    self.compile_expression(&infix.right)?;
                    self.compile_expression(&infix.left)?;

                    self.emit(Opcode::OpGreaterThan, &[]);
                    return Ok(());
                }

                self.compile_expression(&infix.left)?;
                self.compile_expression(&infix.right)?;

                match infix.operator {
                    TokenType::Plus => self.emit(Opcode::OpAdd, &[]),
                    TokenType::Minus => self.emit(Opcode::OpSub, &[]),
                    TokenType::Asterisk => self.emit(Opcode::OpMul, &[]),
                    TokenType::Slash => self.emit(Opcode::OpDiv, &[]),
                    TokenType::Gt => self.emit(Opcode::OpGreaterThan, &[]),
                    TokenType::Eq => self.emit(Opcode::OpEqual, &[]),
                    TokenType::NotEq => self.emit(Opcode::OpNotEqual, &[]),
                    _ => unreachable!("unknown operator"),
                };

                Ok(())
            }
            Expression::PrefixExpression(prefix_expr) => {
                self.compile_expression(&prefix_expr.right)?;

                match prefix_expr.operator {
                    TokenType::Bang => self.emit(Opcode::OpBang, &[]),
                    TokenType::Minus => self.emit(Opcode::OpMinus, &[]),
                    _ => unreachable!("unknown operator"),
                };

                Ok(())
            }
            Expression::Boolean(bool_expr) => {
                match bool_expr.value {
                    true => self.emit(Opcode::OpTrue, &[]),
                    false => self.emit(Opcode::OpFalse, &[]),
                };
                Ok(())
            }
            Expression::IfExpression(if_expr) => {
                self.compile_expression(&if_expr.condition)?;

                let jump_not_truthy_pos = self.emit(Opcode::OpJumpNotTruthy, &[9999]);

                self.compile_block_statement(&if_expr.consequence)?;

                if self.is_last_instruction(Opcode::OpPop) {
                    self.remove_last_pop();
                }

                let jump_pos = self.emit(Opcode::OpJump, &[9999]);

                let after_conseq_position = self.current_instructions().len();
                self.change_operand(
                    jump_not_truthy_pos,
                    after_conseq_position.try_into().unwrap(),
                );

                if let Some(alt) = &if_expr.alternative {
                    self.compile_block_statement(&alt)?;

                    if self.is_last_instruction(Opcode::OpPop) {
                        self.remove_last_pop();
                    }
                } else {
                    self.emit(Opcode::OpNull, &[]);
                }

                let after_alt_position = self.current_instructions().len();
                self.change_operand(jump_pos, after_alt_position.try_into().unwrap());

                Ok(())
            }
            Expression::Identifier(ident) => {
                let symbol = self.symbol_table.resolve(&ident.value);

                let Some(symbol) = symbol else {
                    return Err(CompilerError::UndefinedVariable);
                };

                self.emit(Opcode::OpGetGlobal, &[symbol.index]);

                Ok(())
            }
            Expression::StringLiteral(str_lit) => {
                let str_obj = Object::String(Box::new(StringObj {
                    value: str_lit.value.to_string(),
                }));

                let constant = self.add_constant(str_obj);
                self.emit(Opcode::OpConstant, &[constant]);

                Ok(())
            }
            Expression::ArrayLiteral(arr_lit) => {
                for elem in &arr_lit.elements {
                    self.compile_expression(elem)?;
                }

                self.emit(Opcode::OpArray, &[arr_lit.elements.len() as i64]);

                Ok(())
            }
            Expression::HashLiteral(hash_lit) => {
                let keys: Vec<Expression> = hash_lit.pairs.iter().map(|(k, _)| k.clone()).collect();

                for (i, key) in keys.iter().enumerate() {
                    self.compile_expression(key)?;
                    let value = &hash_lit.pairs[i].1;
                    self.compile_expression(value)?;
                }

                self.emit(
                    Opcode::OpHash,
                    &[(hash_lit.pairs.len() * 2).try_into().unwrap()],
                );

                Ok(())
            }
            Expression::IndexExpression(index_expr) => {
                self.compile_expression(&index_expr.left)?;
                self.compile_expression(&index_expr.index)?;
                self.emit(Opcode::OpIndex, &[]);

                Ok(())
            }
            Expression::FunctionLiteral(func_lit) => {
                self.enter_scope();

                self.compile_block_statement(&func_lit.body)?;

                if self.is_last_instruction(Opcode::OpPop) {
                    self.replace_last_pop_with_return();
                }

                if !self.is_last_instruction(Opcode::OpReturnValue) {
                    self.emit(Opcode::OpReturn, &[]);
                }

                let instructions = self.leave_scope();

                let compiled_fn = Object::CompiledFunction(Box::new(CompiledFunction {
                    instructions: instructions.to_vec(),
                }));

                let constant = self.add_constant(compiled_fn);
                self.emit(Opcode::OpConstant, &[constant]);

                Ok(())
            }
            value => todo!("{:?} not implemented", value),
        }
    }

    /// adds object to pool of constants
    fn add_constant(&mut self, obj: Object) -> i64 {
        self.constants.push(obj);
        (self.constants.len() - 1).try_into().unwrap()
    }

    fn emit(&mut self, opcode: Opcode, operands: &[i64]) -> i64 {
        let instruction = make(opcode, &operands);
        let position = self.add_instruction(&instruction);
        self.set_last_instruction(opcode, position);

        position
    }

    fn add_instruction(&mut self, instruction: &Vec<u8>) -> i64 {
        let pos_new_instruction = self.current_instructions().len();

        self.scopes[self.scope_index]
            .instructions
            .extend(instruction);

        pos_new_instruction.try_into().unwrap()
    }

    fn set_last_instruction(&mut self, opcode: Opcode, position: i64) {
        let prev = self.scopes[self.scope_index].last_instruction;
        let last = EmittedInstruction { opcode, position };

        self.scopes[self.scope_index].prev_instruction = prev;
        self.scopes[self.scope_index].last_instruction = Some(last);
    }

    fn is_last_instruction(&self, opcode: Opcode) -> bool {
        if self.current_instructions().len() == 0 {
            return false;
        }

        self.scopes[self.scope_index]
            .last_instruction
            .is_some_and(|ins| ins.opcode == opcode)
    }

    fn remove_last_pop(&mut self) {
        let last = self.scopes[self.scope_index].last_instruction;
        let prev = self.scopes[self.scope_index].prev_instruction;

        let last_position = last.map_or(0, |v| v.position) as usize;

        let old = self.current_instructions();
        let new = &old[..last_position];

        self.scopes[self.scope_index].instructions = Instructions::from(new.to_vec());
        self.scopes[self.scope_index].last_instruction = prev;
    }

    fn replace_instruction(&mut self, position: i64, new_instruction: Vec<u8>) {
        for i in 0..new_instruction.len() {
            self.scopes[self.scope_index].instructions[position as usize + i] = new_instruction[i];
        }
    }

    fn change_operand(&mut self, op_position: i64, operand: i64) {
        let opcode = Opcode::from_byte(self.current_instructions()[op_position as usize]);

        let Some(opcode) = opcode else {
            return;
        };

        let new_instruction = make(opcode, &[operand]);
        self.replace_instruction(op_position, new_instruction);
    }

    fn replace_last_pop_with_return(&mut self) {
        let last_pos = self.scopes[self.scope_index]
            .last_instruction
            .map_or(0, |i| i.position);

        self.replace_instruction(last_pos, make(Opcode::OpReturnValue, &[]));

        self.scopes[self.scope_index].last_instruction = Some(EmittedInstruction {
            opcode: Opcode::OpReturnValue,
            position: last_pos,
        });
    }
}

#[cfg(test)]
mod tests {
    use monke_core::{ast, lexer::Lexer, object::Object, parser::Parser};

    use crate::{
        code::{self, Instructions, Opcode, make, read_operands},
        compiler::Compiler,
    };

    enum ExpectedConstant {
        I64(i64),
        Bool(bool),
        String(String),
        Instructions(Vec<Instructions>),
    }

    struct CompilerTestCase {
        input: String,
        expected_constants: Vec<ExpectedConstant>,
        expected_instructions: Vec<Instructions>,
    }

    #[test]
    fn test_integer_arithmetic() {
        let tests = vec![
            CompilerTestCase {
                input: "1; 2".to_string(),
                expected_constants: vec![ExpectedConstant::I64(1), ExpectedConstant::I64(2)],
                expected_instructions: vec![
                    Instructions::from(code::make(Opcode::OpConstant, &[0])),
                    Instructions::from(code::make(Opcode::OpPop, &[])),
                    Instructions::from(code::make(Opcode::OpConstant, &[1])),
                    Instructions::from(code::make(Opcode::OpPop, &[])),
                ],
            },
            CompilerTestCase {
                input: "1 + 2".to_string(),
                expected_constants: vec![ExpectedConstant::I64(1), ExpectedConstant::I64(2)],
                expected_instructions: vec![
                    Instructions::from(code::make(Opcode::OpConstant, &[0])),
                    Instructions::from(code::make(Opcode::OpConstant, &[1])),
                    Instructions::from(code::make(Opcode::OpAdd, &[])),
                    Instructions::from(code::make(Opcode::OpPop, &[])),
                ],
            },
            CompilerTestCase {
                input: "1 - 2".to_string(),
                expected_constants: vec![ExpectedConstant::I64(1), ExpectedConstant::I64(2)],
                expected_instructions: vec![
                    Instructions::from(code::make(Opcode::OpConstant, &[0])),
                    Instructions::from(code::make(Opcode::OpConstant, &[1])),
                    Instructions::from(code::make(Opcode::OpSub, &[])),
                    Instructions::from(code::make(Opcode::OpPop, &[])),
                ],
            },
            CompilerTestCase {
                input: "1 * 2".to_string(),
                expected_constants: vec![ExpectedConstant::I64(1), ExpectedConstant::I64(2)],
                expected_instructions: vec![
                    Instructions::from(code::make(Opcode::OpConstant, &[0])),
                    Instructions::from(code::make(Opcode::OpConstant, &[1])),
                    Instructions::from(code::make(Opcode::OpMul, &[])),
                    Instructions::from(code::make(Opcode::OpPop, &[])),
                ],
            },
            CompilerTestCase {
                input: "2 / 1".to_string(),
                expected_constants: vec![ExpectedConstant::I64(2), ExpectedConstant::I64(1)],
                expected_instructions: vec![
                    Instructions::from(code::make(Opcode::OpConstant, &[0])),
                    Instructions::from(code::make(Opcode::OpConstant, &[1])),
                    Instructions::from(code::make(Opcode::OpDiv, &[])),
                    Instructions::from(code::make(Opcode::OpPop, &[])),
                ],
            },
            CompilerTestCase {
                input: "-1".to_string(),
                expected_constants: vec![ExpectedConstant::I64(1)],
                expected_instructions: vec![
                    Instructions::from(code::make(Opcode::OpConstant, &[0])),
                    Instructions::from(code::make(Opcode::OpMinus, &[])),
                    Instructions::from(code::make(Opcode::OpPop, &[])),
                ],
            },
        ];

        run_compiler_tests(tests);
    }

    #[test]
    fn test_instructions_string() {
        let instructions = vec![
            make(Opcode::OpConstant, &[1]),
            make(Opcode::OpConstant, &[2]),
            make(Opcode::OpConstant, &[65535]),
        ];

        let expected = "0000 OpConstant 1 \n0003 OpConstant 2 \n0006 OpConstant 65535 \n";

        let concated: Instructions = instructions.into_iter().flat_map(|i| i).collect();

        assert_eq!(expected, concated.to_string());
    }

    #[test]
    fn test_read_operands() {
        struct TestCase {
            op: Opcode,
            operands: Vec<i64>,
            bytes_read: i64,
        }

        let tests: Vec<TestCase> = vec![TestCase {
            op: Opcode::OpConstant,
            operands: vec![65535],
            bytes_read: 2,
        }];

        for test in tests {
            let instruction = make(test.op, &test.operands);

            let def = test.op.get_definition();

            let (operands_read, n) = read_operands(&def, &instruction[1..]);

            assert_eq!(
                n, test.bytes_read,
                "n wrong. want: {}, got: {}",
                test.bytes_read, n
            );

            for (i, want) in test.operands.iter().enumerate() {
                assert_eq!(
                    operands_read[i], *want,
                    "operand wrong. want: {}, got: {}",
                    want, operands_read[i]
                )
            }
        }
    }

    #[test]
    fn test_boolean_expression() {
        let tests = vec![
            CompilerTestCase {
                input: "true".to_string(),
                expected_constants: vec![],
                expected_instructions: vec![
                    Instructions::from(code::make(Opcode::OpTrue, &[])),
                    Instructions::from(code::make(Opcode::OpPop, &[])),
                ],
            },
            CompilerTestCase {
                input: "false".to_string(),
                expected_constants: vec![],
                expected_instructions: vec![
                    Instructions::from(code::make(Opcode::OpFalse, &[])),
                    Instructions::from(code::make(Opcode::OpPop, &[])),
                ],
            },
            CompilerTestCase {
                input: "1 > 2".to_string(),
                expected_constants: vec![ExpectedConstant::I64(1), ExpectedConstant::I64(2)],
                expected_instructions: vec![
                    Instructions::from(code::make(Opcode::OpConstant, &[0])),
                    Instructions::from(code::make(Opcode::OpConstant, &[1])),
                    Instructions::from(code::make(Opcode::OpGreaterThan, &[])),
                    Instructions::from(code::make(Opcode::OpPop, &[])),
                ],
            },
            CompilerTestCase {
                input: "1 < 2".to_string(),
                expected_constants: vec![ExpectedConstant::I64(2), ExpectedConstant::I64(1)],
                expected_instructions: vec![
                    Instructions::from(code::make(Opcode::OpConstant, &[0])),
                    Instructions::from(code::make(Opcode::OpConstant, &[1])),
                    Instructions::from(code::make(Opcode::OpGreaterThan, &[])),
                    Instructions::from(code::make(Opcode::OpPop, &[])),
                ],
            },
            CompilerTestCase {
                input: "1 == 2".to_string(),
                expected_constants: vec![ExpectedConstant::I64(1), ExpectedConstant::I64(2)],
                expected_instructions: vec![
                    Instructions::from(code::make(Opcode::OpConstant, &[0])),
                    Instructions::from(code::make(Opcode::OpConstant, &[1])),
                    Instructions::from(code::make(Opcode::OpEqual, &[])),
                    Instructions::from(code::make(Opcode::OpPop, &[])),
                ],
            },
            CompilerTestCase {
                input: "1 != 2".to_string(),
                expected_constants: vec![ExpectedConstant::I64(1), ExpectedConstant::I64(2)],
                expected_instructions: vec![
                    Instructions::from(code::make(Opcode::OpConstant, &[0])),
                    Instructions::from(code::make(Opcode::OpConstant, &[1])),
                    Instructions::from(code::make(Opcode::OpNotEqual, &[])),
                    Instructions::from(code::make(Opcode::OpPop, &[])),
                ],
            },
            CompilerTestCase {
                input: "true == false".to_string(),
                expected_constants: vec![],
                expected_instructions: vec![
                    Instructions::from(code::make(Opcode::OpTrue, &[])),
                    Instructions::from(code::make(Opcode::OpFalse, &[])),
                    Instructions::from(code::make(Opcode::OpEqual, &[])),
                    Instructions::from(code::make(Opcode::OpPop, &[])),
                ],
            },
            CompilerTestCase {
                input: "true != false".to_string(),
                expected_constants: vec![],
                expected_instructions: vec![
                    Instructions::from(code::make(Opcode::OpTrue, &[])),
                    Instructions::from(code::make(Opcode::OpFalse, &[])),
                    Instructions::from(code::make(Opcode::OpNotEqual, &[])),
                    Instructions::from(code::make(Opcode::OpPop, &[])),
                ],
            },
            CompilerTestCase {
                input: "!true".to_string(),
                expected_constants: vec![],
                expected_instructions: vec![
                    Instructions::from(code::make(Opcode::OpTrue, &[])),
                    Instructions::from(code::make(Opcode::OpBang, &[])),
                    Instructions::from(code::make(Opcode::OpPop, &[])),
                ],
            },
        ];

        run_compiler_tests(tests);
    }

    #[test]
    fn test_conditionals() {
        let tests = vec![
            CompilerTestCase {
                input: "if (true) { 10 } else { 20 }; 3333;".to_string(),
                expected_constants: vec![
                    ExpectedConstant::I64(10),
                    ExpectedConstant::I64(20),
                    ExpectedConstant::I64(3333),
                ],
                expected_instructions: vec![
                    Instructions::from(make(Opcode::OpTrue, &[])),
                    Instructions::from(make(Opcode::OpJumpNotTruthy, &[10])),
                    Instructions::from(make(Opcode::OpConstant, &[0])),
                    Instructions::from(make(Opcode::OpJump, &[13])),
                    Instructions::from(make(Opcode::OpConstant, &[1])),
                    Instructions::from(make(Opcode::OpPop, &[])),
                    Instructions::from(make(Opcode::OpConstant, &[2])),
                    Instructions::from(make(Opcode::OpPop, &[])),
                ],
            },
            CompilerTestCase {
                input: "if (true) { 10 }; 3333;".to_string(),
                expected_constants: vec![ExpectedConstant::I64(10), ExpectedConstant::I64(3333)],
                expected_instructions: vec![
                    Instructions::from(make(Opcode::OpTrue, &[])),
                    Instructions::from(make(Opcode::OpJumpNotTruthy, &[10])),
                    Instructions::from(make(Opcode::OpConstant, &[0])),
                    Instructions::from(make(Opcode::OpJump, &[11])),
                    Instructions::from(make(Opcode::OpNull, &[])),
                    Instructions::from(make(Opcode::OpPop, &[])),
                    Instructions::from(make(Opcode::OpConstant, &[1])),
                    Instructions::from(make(Opcode::OpPop, &[])),
                ],
            },
        ];

        run_compiler_tests(tests);
    }

    #[test]
    fn test_global_let_statements() {
        let tests = vec![
            CompilerTestCase {
                input: "
                let one = 1;
                let two = 2;
                "
                .to_string(),
                expected_constants: vec![ExpectedConstant::I64(1), ExpectedConstant::I64(2)],
                expected_instructions: vec![
                    Instructions::from(make(Opcode::OpConstant, &[0])),
                    Instructions::from(make(Opcode::OpSetGlobal, &[0])),
                    Instructions::from(make(Opcode::OpConstant, &[1])),
                    Instructions::from(make(Opcode::OpSetGlobal, &[1])),
                ],
            },
            CompilerTestCase {
                input: "
                let one = 1;
                one;
                "
                .to_string(),
                expected_constants: vec![ExpectedConstant::I64(1)],
                expected_instructions: vec![
                    Instructions::from(make(Opcode::OpConstant, &[0])),
                    Instructions::from(make(Opcode::OpSetGlobal, &[0])),
                    Instructions::from(make(Opcode::OpGetGlobal, &[0])),
                    Instructions::from(make(Opcode::OpPop, &[])),
                ],
            },
            CompilerTestCase {
                input: "
                let one = 1;
                let two = one;
                two;
                "
                .to_string(),
                expected_constants: vec![ExpectedConstant::I64(1)],
                expected_instructions: vec![
                    Instructions::from(make(Opcode::OpConstant, &[0])),
                    Instructions::from(make(Opcode::OpSetGlobal, &[0])),
                    Instructions::from(make(Opcode::OpGetGlobal, &[0])),
                    Instructions::from(make(Opcode::OpSetGlobal, &[1])),
                    Instructions::from(make(Opcode::OpGetGlobal, &[1])),
                    Instructions::from(make(Opcode::OpPop, &[])),
                ],
            },
        ];

        run_compiler_tests(tests);
    }

    #[test]
    fn test_string_expressions() {
        let tests = vec![
            CompilerTestCase {
                input: r#""monkey""#.to_string(),
                expected_constants: vec![ExpectedConstant::String("monkey".to_string())],
                expected_instructions: vec![
                    Instructions::from(make(Opcode::OpConstant, &[0])),
                    Instructions::from(make(Opcode::OpPop, &[])),
                ],
            },
            CompilerTestCase {
                input: r#""mon" + "key""#.to_string(),
                expected_constants: vec![
                    ExpectedConstant::String("mon".to_string()),
                    ExpectedConstant::String("key".to_string()),
                ],
                expected_instructions: vec![
                    Instructions::from(make(Opcode::OpConstant, &[0])),
                    Instructions::from(make(Opcode::OpConstant, &[1])),
                    Instructions::from(make(Opcode::OpAdd, &[])),
                    Instructions::from(make(Opcode::OpPop, &[])),
                ],
            },
        ];

        run_compiler_tests(tests);
    }

    #[test]
    fn test_array_literals() {
        let tests = vec![
            CompilerTestCase {
                input: "[]".to_string(),
                expected_constants: vec![],
                expected_instructions: vec![
                    Instructions::from(make(Opcode::OpArray, &[0])),
                    Instructions::from(make(Opcode::OpPop, &[])),
                ],
            },
            CompilerTestCase {
                input: "[1,2,3]".to_string(),
                expected_constants: vec![
                    ExpectedConstant::I64(1),
                    ExpectedConstant::I64(2),
                    ExpectedConstant::I64(3),
                ],
                expected_instructions: vec![
                    Instructions::from(make(Opcode::OpConstant, &[0])),
                    Instructions::from(make(Opcode::OpConstant, &[1])),
                    Instructions::from(make(Opcode::OpConstant, &[2])),
                    Instructions::from(make(Opcode::OpArray, &[3])),
                    Instructions::from(make(Opcode::OpPop, &[])),
                ],
            },
            CompilerTestCase {
                input: "[1 + 2, 3 - 4, 5 * 6]".to_string(),
                expected_constants: vec![
                    ExpectedConstant::I64(1),
                    ExpectedConstant::I64(2),
                    ExpectedConstant::I64(3),
                    ExpectedConstant::I64(4),
                    ExpectedConstant::I64(5),
                    ExpectedConstant::I64(6),
                ],
                expected_instructions: vec![
                    Instructions::from(make(Opcode::OpConstant, &[0])),
                    Instructions::from(make(Opcode::OpConstant, &[1])),
                    Instructions::from(make(Opcode::OpAdd, &[])),
                    Instructions::from(make(Opcode::OpConstant, &[2])),
                    Instructions::from(make(Opcode::OpConstant, &[3])),
                    Instructions::from(make(Opcode::OpSub, &[])),
                    Instructions::from(make(Opcode::OpConstant, &[4])),
                    Instructions::from(make(Opcode::OpConstant, &[5])),
                    Instructions::from(make(Opcode::OpMul, &[])),
                    Instructions::from(make(Opcode::OpArray, &[3])),
                    Instructions::from(make(Opcode::OpPop, &[])),
                ],
            },
        ];

        run_compiler_tests(tests);
    }

    #[test]
    fn test_hash_literals() {
        let tests = vec![
            CompilerTestCase {
                input: "{}".to_string(),
                expected_constants: vec![],
                expected_instructions: vec![
                    Instructions::from(make(Opcode::OpHash, &[0])),
                    Instructions::from(make(Opcode::OpPop, &[])),
                ],
            },
            CompilerTestCase {
                input: "{1: 2, 3: 4, 5: 6}".to_string(),
                expected_constants: vec![
                    ExpectedConstant::I64(1),
                    ExpectedConstant::I64(2),
                    ExpectedConstant::I64(3),
                    ExpectedConstant::I64(4),
                    ExpectedConstant::I64(5),
                    ExpectedConstant::I64(6),
                ],
                expected_instructions: vec![
                    Instructions::from(make(Opcode::OpConstant, &[0])),
                    Instructions::from(make(Opcode::OpConstant, &[1])),
                    Instructions::from(make(Opcode::OpConstant, &[2])),
                    Instructions::from(make(Opcode::OpConstant, &[3])),
                    Instructions::from(make(Opcode::OpConstant, &[4])),
                    Instructions::from(make(Opcode::OpConstant, &[5])),
                    Instructions::from(make(Opcode::OpHash, &[6])),
                    Instructions::from(make(Opcode::OpPop, &[])),
                ],
            },
            CompilerTestCase {
                input: "{1: 2 + 3, 4: 5 * 6}".to_string(),
                expected_constants: vec![
                    ExpectedConstant::I64(1),
                    ExpectedConstant::I64(2),
                    ExpectedConstant::I64(3),
                    ExpectedConstant::I64(4),
                    ExpectedConstant::I64(5),
                    ExpectedConstant::I64(6),
                ],
                expected_instructions: vec![
                    Instructions::from(make(Opcode::OpConstant, &[0])),
                    Instructions::from(make(Opcode::OpConstant, &[1])),
                    Instructions::from(make(Opcode::OpConstant, &[2])),
                    Instructions::from(make(Opcode::OpAdd, &[])),
                    Instructions::from(make(Opcode::OpConstant, &[3])),
                    Instructions::from(make(Opcode::OpConstant, &[4])),
                    Instructions::from(make(Opcode::OpConstant, &[5])),
                    Instructions::from(make(Opcode::OpMul, &[])),
                    Instructions::from(make(Opcode::OpHash, &[4])),
                    Instructions::from(make(Opcode::OpPop, &[])),
                ],
            },
        ];

        run_compiler_tests(tests);
    }

    #[test]
    fn test_index_expressions() {
        let tests = vec![
            CompilerTestCase {
                input: "[1, 2, 3][1 + 1]".to_string(),
                expected_constants: vec![
                    ExpectedConstant::I64(1),
                    ExpectedConstant::I64(2),
                    ExpectedConstant::I64(3),
                    ExpectedConstant::I64(1),
                    ExpectedConstant::I64(1),
                ],
                expected_instructions: vec![
                    Instructions::from(make(Opcode::OpConstant, &[0])),
                    Instructions::from(make(Opcode::OpConstant, &[1])),
                    Instructions::from(make(Opcode::OpConstant, &[2])),
                    Instructions::from(make(Opcode::OpArray, &[3])),
                    Instructions::from(make(Opcode::OpConstant, &[3])),
                    Instructions::from(make(Opcode::OpConstant, &[4])),
                    Instructions::from(make(Opcode::OpAdd, &[])),
                    Instructions::from(make(Opcode::OpIndex, &[])),
                    Instructions::from(make(Opcode::OpPop, &[])),
                ],
            },
            CompilerTestCase {
                input: "{1: 2}[2 - 1]".to_string(),
                expected_constants: vec![
                    ExpectedConstant::I64(1),
                    ExpectedConstant::I64(2),
                    ExpectedConstant::I64(2),
                    ExpectedConstant::I64(1),
                ],
                expected_instructions: vec![
                    Instructions::from(make(Opcode::OpConstant, &[0])),
                    Instructions::from(make(Opcode::OpConstant, &[1])),
                    Instructions::from(make(Opcode::OpHash, &[2])),
                    Instructions::from(make(Opcode::OpConstant, &[2])),
                    Instructions::from(make(Opcode::OpConstant, &[3])),
                    Instructions::from(make(Opcode::OpSub, &[])),
                    Instructions::from(make(Opcode::OpIndex, &[])),
                    Instructions::from(make(Opcode::OpPop, &[])),
                ],
            },
        ];

        run_compiler_tests(tests);
    }

    #[test]
    fn test_functions() {
        let tests = vec![
            CompilerTestCase {
                input: "function() { return 5 + 10 }".to_string(),
                expected_constants: vec![
                    ExpectedConstant::I64(5),
                    ExpectedConstant::I64(10),
                    ExpectedConstant::Instructions(vec![
                        Instructions::from(make(Opcode::OpConstant, &[0])),
                        Instructions::from(make(Opcode::OpConstant, &[1])),
                        Instructions::from(make(Opcode::OpAdd, &[])),
                        Instructions::from(make(Opcode::OpReturnValue, &[])),
                    ]),
                ],
                expected_instructions: vec![
                    Instructions::from(make(Opcode::OpConstant, &[2])),
                    Instructions::from(make(Opcode::OpPop, &[])),
                ],
            },
            CompilerTestCase {
                input: "function() { 5 + 10 }".to_string(),
                expected_constants: vec![
                    ExpectedConstant::I64(5),
                    ExpectedConstant::I64(10),
                    ExpectedConstant::Instructions(vec![
                        Instructions::from(make(Opcode::OpConstant, &[0])),
                        Instructions::from(make(Opcode::OpConstant, &[1])),
                        Instructions::from(make(Opcode::OpAdd, &[])),
                        Instructions::from(make(Opcode::OpReturnValue, &[])),
                    ]),
                ],
                expected_instructions: vec![
                    Instructions::from(make(Opcode::OpConstant, &[2])),
                    Instructions::from(make(Opcode::OpPop, &[])),
                ],
            },
            CompilerTestCase {
                input: "function() { 1; 2 }".to_string(),
                expected_constants: vec![
                    ExpectedConstant::I64(1),
                    ExpectedConstant::I64(2),
                    ExpectedConstant::Instructions(vec![
                        Instructions::from(make(Opcode::OpConstant, &[0])),
                        Instructions::from(make(Opcode::OpPop, &[])),
                        Instructions::from(make(Opcode::OpConstant, &[1])),
                        Instructions::from(make(Opcode::OpReturnValue, &[])),
                    ]),
                ],
                expected_instructions: vec![
                    Instructions::from(make(Opcode::OpConstant, &[2])),
                    Instructions::from(make(Opcode::OpPop, &[])),
                ],
            },
            CompilerTestCase {
                input: "function() {}".to_string(),
                expected_constants: vec![ExpectedConstant::Instructions(vec![Instructions::from(
                    make(Opcode::OpReturn, &[]),
                )])],
                expected_instructions: vec![
                    Instructions::from(make(Opcode::OpConstant, &[0])),
                    Instructions::from(make(Opcode::OpPop, &[])),
                ],
            },
        ];

        run_compiler_tests(tests);
    }

    #[test]
    fn test_compiler_scopes() {
        let mut compiler = Compiler::new();

        assert_eq!(0, compiler.scope_index);

        compiler.emit(Opcode::OpMul, &[]);
        compiler.enter_scope();
        assert_eq!(1, compiler.scope_index);

        compiler.emit(Opcode::OpSub, &[]);
        assert_eq!(1, compiler.scopes[compiler.scope_index].instructions.len());

        let last = compiler.scopes[compiler.scope_index]
            .last_instruction
            .expect("last_instruction doesnt exist");
        assert_eq!(last.opcode, Opcode::OpSub);

        compiler.leave_scope();
        assert_eq!(0, compiler.scope_index);

        compiler.emit(Opcode::OpAdd, &[]);
        assert_eq!(2, compiler.scopes[compiler.scope_index].instructions.len());

        let last = compiler.scopes[compiler.scope_index]
            .last_instruction
            .expect("last_instruction doesnt exist");
        assert_eq!(last.opcode, Opcode::OpAdd);

        let prev = compiler.scopes[compiler.scope_index]
            .prev_instruction
            .expect("prev_instruction doesnt exist");
        assert_eq!(prev.opcode, Opcode::OpMul);
    }

    fn run_compiler_tests(tests: Vec<CompilerTestCase>) {
        for test in tests {
            let program = parse(test.input);
            let mut compiler = Compiler::new();

            assert!(
                compiler.compile(program).is_ok(),
                "failed to compile program"
            );

            let bytecode = compiler.bytecode();

            test_instructions(test.expected_instructions, bytecode.instructions);
            test_constants(test.expected_constants, bytecode.constants);
        }
    }

    fn test_constants(expected: Vec<ExpectedConstant>, actual: Vec<Object>) {
        assert_eq!(
            actual.len(),
            expected.len(),
            "wrong constants length, want: {}, got: {}",
            expected.len(),
            actual.len()
        );

        for (idx, constant) in expected.into_iter().enumerate() {
            match constant {
                ExpectedConstant::I64(constant) => test_integer_object(&constant, &actual[idx]),
                ExpectedConstant::Bool(boolean) => test_boolean_object(&boolean, &actual[idx]),
                ExpectedConstant::String(string) => test_string_object(&string, &actual[idx]),
                ExpectedConstant::Instructions(items) => {
                    let Object::CompiledFunction(compiled_fn) = &actual[idx] else {
                        panic!("object is not CompiledFunction. got: {}", actual[idx]);
                    };

                    test_instructions(
                        items,
                        code::Instructions::from(compiled_fn.instructions.clone()),
                    );
                }
            }
        }
    }

    fn test_boolean_object(expected: &bool, actual: &Object) {
        let Object::Boolean(bool_obj) = actual else {
            panic!("object is not Integer. got: {}", actual);
        };

        assert_eq!(
            bool_obj.value, *expected,
            "object has wrong value. got: {}, want: {}",
            bool_obj.value, expected
        );
    }

    fn test_integer_object(expected: &i64, actual: &Object) {
        let Object::Integer(int_obj) = actual else {
            panic!("object is not Integer. got: {}", actual);
        };

        assert_eq!(
            int_obj.value, *expected,
            "object has wrong value. got: {}, want: {}",
            int_obj.value, expected
        );
    }

    fn test_string_object(expected: &str, actual: &Object) {
        let Object::String(str_obj) = actual else {
            panic!("object is not String. got: {}", actual);
        };

        assert_eq!(
            str_obj.value, *expected,
            "object has wrong value. got: {}, want: {}",
            str_obj.value, expected
        );
    }

    fn test_instructions(expected: Vec<Instructions>, actual: Instructions) {
        let concated: Instructions = expected.into_iter().flat_map(|i| i).collect();

        assert_eq!(
            actual.len(),
            concated.len(),
            "wrong instructions length, want: {}, got: {}",
            concated,
            actual
        );

        for (idx, ins) in concated.iter().enumerate() {
            assert_eq!(
                actual[idx], *ins,
                "wrong instruction at {}, want: {}, got: {}",
                idx, ins, actual[idx]
            )
        }
    }

    fn parse(input: String) -> ast::Program {
        let lexer = Lexer::new(input);
        let mut parser = Parser::new(lexer);
        return parser.parse_program();
    }
}
