use monke_core::{
    ast::{Expression, Program, Statement},
    object::{Integer, Object},
};

use crate::code::{Definition, Instructions, Opcode, make};

pub struct Compiler {
    /// holds generated bytecode
    instructions: Instructions,

    /// constant pool
    constants: Vec<Object>,
}

struct Bytecode {
    instructions: Instructions,
    constants: Vec<Object>,
}

impl Compiler {
    pub fn new() -> Self {
        Self {
            instructions: Instructions::new(),
            constants: vec![],
        }
    }

    pub fn compile(&mut self, program: Program) -> Result<(), ()> {
        for stmt in program.body {
            let result = self.compile_statement(&stmt);

            if result.is_err() {
                return result;
            }
        }

        Ok(())
    }

    fn compile_statement(&mut self, statement: &Statement) -> Result<(), ()> {
        match statement {
            Statement::ExpressionStatement(expression_statement) => {
                if let Some(expression) = &expression_statement.expression {
                    return self.compile_expression(&expression);
                }

                Err(())
            }
            Statement::LetStatement(let_statement) => todo!(),
            Statement::ReturnStatement(return_statement) => todo!(),
            Statement::BlockStatement(block_statement) => todo!(),
            Statement::ForStatement(for_statement) => todo!(),
        }
    }

    pub fn bytecode(&self) -> Bytecode {
        Bytecode {
            instructions: self.instructions.clone(),
            constants: self.constants.clone(),
        }
    }

    fn compile_expression(&mut self, expression: &Expression) -> Result<(), ()> {
        match expression {
            Expression::IntegerLiteral(integer_literal) => {
                let integer = Object::Integer(Box::new(Integer {
                    value: integer_literal.value,
                }));

                let index = self.add_constant(integer);
                self.emit(Opcode::OpConstant, vec![index]);

                Ok(())
            }
            Expression::InfixExpression(infix) => {
                let left_result = self.compile_expression(&infix.left);

                if left_result.is_err() {
                    return left_result;
                }

                let right_result = self.compile_expression(&infix.right);

                if right_result.is_err() {
                    return right_result;
                }

                Ok(())
            }
            _ => todo!(),
        }
    }

    /// adds object to pool of constants
    fn add_constant(&mut self, obj: Object) -> i64 {
        self.constants.push(obj);
        (self.constants.len() - 1).try_into().unwrap()
    }

    fn emit(&mut self, opcode: Opcode, operands: Vec<i64>) -> i64 {
        let instruction = make(opcode, &operands);
        let position = self.add_instruction(instruction);
        position
    }

    fn add_instruction(&mut self, instruction: Vec<u8>) -> i64 {
        let pos_new_instruction = self.instructions.len();
        self.instructions.extend(instruction);
        pos_new_instruction.try_into().unwrap()
    }
}

#[cfg(test)]
mod tests {
    use monke_core::{ast, lexer::Lexer, object::Object, parser::Parser};

    use crate::{
        code::{self, Instructions, Opcode, make, read_operands},
        compiler::Compiler,
    };

    enum ExpectedConstant {
        I64(i64),
    }

    struct CompilerTestCase {
        input: String,
        expected_constants: Vec<ExpectedConstant>,
        expected_instructions: Vec<Instructions>,
    }

    #[test]
    fn test_integer_arithmetic() {
        let tests = vec![CompilerTestCase {
            input: "1 + 2".to_string(),
            expected_constants: vec![ExpectedConstant::I64(1), ExpectedConstant::I64(2)],
            expected_instructions: vec![
                Instructions(code::make(code::Opcode::OpConstant, &vec![0])),
                Instructions(code::make(code::Opcode::OpConstant, &vec![1])),
            ],
        }];

        run_compiler_tests(tests);
    }

    #[test]
    fn test_instructions_string() {
        let instructions = vec![
            make(code::Opcode::OpConstant, &vec![1]),
            make(code::Opcode::OpConstant, &vec![2]),
            make(code::Opcode::OpConstant, &vec![65535]),
        ];

        let expected = "0000 OpConstant 1 \n0003 OpConstant 2 \n0006 OpConstant 65535 \n";

        let concated: Instructions = instructions.into_iter().flat_map(|i| i).collect();

        assert_eq!(expected, concated.to_string());
    }

    #[test]
    fn test_read_operands() {
        struct TestCase {
            op: Opcode,
            operands: Vec<i64>,
            bytes_read: i64,
        }

        let tests: Vec<TestCase> = vec![TestCase {
            op: Opcode::OpConstant,
            operands: vec![65535],
            bytes_read: 2,
        }];

        for test in tests {
            let instruction = make(test.op, &test.operands);

            let def = test.op.get_definition();

            let (operands_read, n) = read_operands(&def, &instruction[1..]);

            assert_eq!(
                n, test.bytes_read,
                "n wrong. want: {}, got: {}",
                test.bytes_read, n
            );

            for (i, want) in test.operands.iter().enumerate() {
                assert_eq!(
                    operands_read[i], *want,
                    "operand wrong. want: {}, got: {}",
                    want, operands_read[i]
                )
            }
        }
    }

    fn run_compiler_tests(tests: Vec<CompilerTestCase>) {
        for test in tests {
            let program = parse(test.input);
            let mut compiler = Compiler::new();

            assert!(
                compiler.compile(program).is_ok(),
                "failed to compile program"
            );

            let bytecode = compiler.bytecode();

            test_instructions(test.expected_instructions, bytecode.instructions);
            test_constants(test.expected_constants, bytecode.constants);
        }
    }

    fn test_constants(expected: Vec<ExpectedConstant>, actual: Vec<Object>) {
        assert_eq!(
            actual.len(),
            expected.len(),
            "wrong constants length, want: {}, got: {}",
            expected.len(),
            actual.len()
        );

        for (idx, constant) in expected.iter().enumerate() {
            match constant {
                ExpectedConstant::I64(constant) => test_integer_object(constant, &actual[idx]),
            }
        }
    }

    fn test_integer_object(expected: &i64, actual: &Object) {
        let Object::Integer(int_obj) = actual else {
            panic!("object is not Integer. got: {}", actual);
        };

        assert_eq!(
            int_obj.value, *expected,
            "object has wrong value. got: {}, want: {}",
            int_obj.value, expected
        );
    }

    fn test_instructions(expected: Vec<Instructions>, actual: Instructions) {
        let concated: Instructions = expected.into_iter().flat_map(|i| i).collect();

        assert_eq!(
            actual.len(),
            concated.len(),
            "wrong instructions length, want: {}, got: {}",
            concated,
            actual
        );

        for (idx, ins) in concated.iter().enumerate() {
            assert_eq!(
                actual[idx], *ins,
                "wrong instruction at {}, want: {}, got: {}",
                idx, ins, actual[idx]
            )
        }
    }

    fn parse(input: String) -> ast::Program {
        let lexer = Lexer::new(input);
        let mut parser = Parser::new(lexer);
        return parser.parse_program();
    }
}
